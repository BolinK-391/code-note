#include "stdio.h"
int main(){
    int a[3][4] = {0};

    printf("%d\n",sizeof(a));//输出48 = 3 * 4 * sizeof(int)

    printf("%d\n",sizeof(a[0]));//输出16

    printf("%d\n",sizeof(a[0] + 1));//输出4：a[0]作为数组名并没有单独放在sizeof内部，
                                          //也没取地址，所以a[0]就是第一行第一个算的地址
                                          //a[0]+1，就是第一行第二个元素的地址
    printf("%d\n",sizeof(a + 1));//输出4：a是二维数组的数组名，并没有取地址
                                       //也没有单独放在sizeof()内部，所以a就表示二维数组首元素的地址，即：第一行的地址
                                       //a+1就是二维数组第二行的地址
    printf("%d\n",sizeof(*(a + 1)));//输出16：*(a+1) --> a[1]
    printf("%d\n",sizeof(&a[0] + 1));//输出4：a[0]是第一行的数组名，
                                           // &a[0]取出的就是第一行的地址，&a[0]+1就是第二行的地址
                                           //和sizeof(a + 1)意思相同
    printf("%d\n",sizeof(*(&a[0] + 1)));//输出16
    printf("%d\n",sizeof(*a));//输出16：解引用第一行(同*(a+0)-->a[0])
    printf("%d\n",sizeof(a[3]));//输出16，其实没有访问到a[3]
                                      //a[3]的类型：int[4]  根据类型直接判断得16
                                      //sizeof()内部的表达式是不计算的，所以不会真正去访问这个地址，只是靠类型计算大小的
    return 0;
}

//a是二维数组的数组名，并没有取地址
//也没有单独放在sizeof()内部，所以a就表示二维数组首元素的地址，即：第一行的地址
//*a就是第一行
//a+1就是二维数组第二行的地址

//sizeof()不会越界访问
//short s = 5    int a = 4
//sizeof(s = a + 6)
//sizeof()内部的表达式不参与计算，所以s的值一直没变
//根据s是short类型sizeof输出结果为2，不会因为int类型加减将short类型转换为int类型