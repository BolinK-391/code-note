>>Clion调试阶段：
printf打印不出数据来，编译运行，结果打印不出exe结果。因为没遇到换行也没有填满缓冲区，所以打印不出来，再看。

在main（）
{
}的内部前面添加一行
setbuf(stdout,NULL);

setbuf函数用于打开和关闭缓冲机制，关闭缓冲区的功能。
void setbuf ( FILE * stream, char * buffer );
设置流缓冲区
指定流用于 I/O 操作的缓冲区，该缓冲区将成为完全缓冲的流。或者，如果 buffer 为 null 指针，则对流禁用缓冲，该流将成为无缓冲流。

一旦流与打开的文件关联，但在对它执行任何输入或输出操作之前，应调用此函数。





>>C编译报错: implicit declaration of function xxx is invalid in C99 [-Wimplicit-function-declaration]

产生原因：
C语言是过程化的编程语言，程序执行顺序是从上到下。函数调用需要先声明后调用。 C99 默认不允许隐式声明(1999年推出的c语言标准)。
在之前的版本中，在C语言函数在调用前不声明，编译器会自动按照一种隐式声明的规则，为调用函数的C代码产生汇编代码。

解决办法：
在 main 函数调用前声明一下该函数。
（1）直接放到 main 函数前。
（2）或者定义在 .h 头文件中，在main函数前 引入该头文件。
（3）使用老版本编译。 【不推荐】





>>对字体（前景色）颜色进行调用的函数

void color(const unsigned short textColor)      //自定义函根据参数改变颜色 
{
    if(textColor>=0 && textColor<=15)     //参数在0-15的范围颜色
         SetConsoleTextAttribute(GetStdHandle(STD_OUTPUT_HANDLE), textColor);  //用一个参数，改变字体颜色
    else   //默认的字体颜色是白色
        SetConsoleTextAttribute(GetStdHandle(STD_OUTPUT_HANDLE), 7);
}

color(0); printf("黑色\n");
    color(1);  printf("蓝色\n");
    color(2);  printf("绿色\n"); 
    color(3);  printf("湖蓝色\n");
    color(4);   printf("红色\n");
    color(5);   printf("紫色\n");
    color(6);  printf("黄色\n"); 
    color(7);   printf("白色\n");
    color(8);   printf("灰色\n");
    color(9);  printf("淡蓝色\n");
    color(10);  printf("淡绿色\n");
    color(11);  printf("淡浅绿色\n"); 
    color(12);  printf("淡红色\n");
    color(13);  printf("淡紫色\n"); 
    color(14);  printf("淡黄色\n");
    color(15);  printf("亮白色\n");
    color(16);    //因为这里大于15，恢复默认的颜色 
    printf("回到原来颜色\n");   //直接使用颜色函数





>>关于局部变量在栈区上的使用

[ 错误代码 -- 会死循环 ]

#include <stdio.h>
int main()
{
    int i = 0;
    int arr[10] = {0};
    for(i=0; i<=12; i++)
   {
        arr[i] = 0;
        printf("hehe\n");
   }
    return 0;
}

分析：
1.  i和arr是局部变量                                                                    
     局部变量是放在栈区上的
     
     栈区内存的使用习惯是：
     先使用高地址空间，再使用低地址空间

2.  数组随着下标的增长地址
     是由低到高变化的
_______________________
|______________________|    高地址
|______________________|  <<<<   i     ( 根据代码显示是先创建的 i，所以在栈区中 i 在 arr 的上面 )
|______________________|
|______________________|
|______________________|  <<<<   arr [ 9 ]
|______________________|
|______________________|   ......
|______________________|
|______________________|  <<<<   arr [ 0 ]
|______________________|
|______________________|
|______________________|     低地址

（ 空两格是巧合，每个环境下可能都不一样 ）
[  没有报错是因为程序在死循环的走，不然就会报错为非法访问地址 ( 如果改成先创建arr再创建i的话就不会死循环，但是会报错非法访问地址 )  ]





>>位运算（按位与、按位或、异或）

按位与运算符（&）
参加运算的两个数，按二进制位进行“与”运算。

运算规则：只有两个数的二进制同时为1，结果才为1，否则为0。（负数按补码形式参加按位与运算）

即 0 & 0= 0 ，0 & 1= 0，1 & 0= 0， 1 & 1= 1。

例：3 &5  即 00000011 & 00000101 = 00000001 ，所以 3 & 5的值为1。

 

按位或运算符（|）
参加运算的两个数，按二进制位进行“或”运算。

运算规则：参加运算的两个数只要两个数中的一个为1，结果就为1。

即  0 | 0= 0 ,  1 | 0= 1  ， 0 | 1= 1  ,  1 | 1= 1 。

例：2 | 4 即 00000010 | 00000100 = 00000110 ，所以2 | 4的值为 6 。

 

异或运算符（^）
参加运算的两个数，按二进制位进行“异或”运算。

运算规则：参加运算的两个数，如果两个相应位为“异”（值不同），则该位结果为1，否则为0。

即 0 ^ 0=0  ， 0 ^ 1= 1  ， 1 ^ 0= 1  ， 1 ^ 1= 0 。

例： 2 ^ 4 即 00000010 ^ 00000100 =00000110 ，所以 2 ^ 4 的值为6 。





>>数据在内存中以2进制的形式存储
对于整数来说：

整数二进制有3种表示形式：原码、反码、补码
正整数：原码、反码、补码相同
负整数：原码、反码、补码要进行计算的


例：int a = -10 ( 32位 )

原码：按照数据的数值直接写出的二进制序列就是原码
           10000000000000000000000000001010 - 原码

反码：原码的符号位不变，其他位按位取反，得到的就是反码
           11111111111111111111111111110101- 反码

补码：反码 +1 ，得到的就是补码
           11111111111111111111111111110110- 补码

( 整数在内存中存储的是补码 ) 
在计算机系统中，数值一律用补码来表示和存储。原因在于，使用补码，可以将符号位和数值域统一处理；
同时，加法和减法也可以统一处理（CPU只有加法器）此外，补码与原码相互转换，其运算过程是相同的，不需要额外的硬件电路。





>>大小端：

int a = 0x11223344

	_______________________
	|                                    |
低	|   | 11 | 22 | 33 | 44 |   |	  高	
	|______________________|
             大端（存储）模式

	_______________________
	|                                    |
低	|   | 44 | 33 | 22 | 11 |   |	  高
	|______________________|
             小端（存储）模式


大端（存储）模式，是指数据的低位保存在内存的高地址中，而数据的高位，保存在内存的低地址中；
小端（存储）模式，是指数据的低位保存在内存的低地址中，而数据的高位,，保存在内存的高地址中。





>>char类型存放整数

char  内存            %d输出整数
_______________
|   00000000   | ->0                                        
|   00000001   | ->1	                                
|   00000010   | ->2                                        
|        ....           |                                               
|   01111111   | ->127 	                                
|--------------|                                             形成圆形成一个循环  
|   10000000   | ->-128                                  
|   10000001   | ->-127	                                
|   10000010   | ->-126                                  
|        ....           |                                                
|   11111110   | ->-2                                     
|   11111111   | ->-1 	                                
|______________|                                                

//巧记口诀:超出范围的数据如果是正数，则减去256;超出范围的数据如果是负数，则加上256.

如果是 unsigned char 的话就是从 0 - 255
因为char是一字节只有8个比特位所以最大就是11111111 '255'





>>数组名是数组首元素的地址

     但是有两个例外

1.sizeof(数组名) - 数组名表示整个数组，计算的是整个数组大小，单位是字节
2. &数组名 - 数组名表示整个数组，取出的是整个数组的地址

计算数组元素个数  len = sizeof（arr）/  sizeof（arr[0]）

——  > sizeof 是操作符，计算变量（类型）所占内存空间的大小，单位是字节，不关注内存中存放的内容

——  > strlen 是库函数，使用时需要引头文件，专门求字符串长度，只能针对字符串，向后一直找\0，统计\0之前出现的字符个数 
