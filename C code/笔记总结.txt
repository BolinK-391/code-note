>>Clion调试阶段：
printf打印不出数据来，编译运行，结果打印不出exe结果。因为没遇到换行也没有填满缓冲区，所以打印不出来，再看。

在main（）
{
}的内部前面添加一行
setbuf(stdout,NULL);

setbuf函数用于打开和关闭缓冲机制，关闭缓冲区的功能。
void setbuf ( FILE * stream, char * buffer );
设置流缓冲区
指定流用于 I/O 操作的缓冲区，该缓冲区将成为完全缓冲的流。或者，如果 buffer 为 null 指针，则对流禁用缓冲，该流将成为无缓冲流。

一旦流与打开的文件关联，但在对它执行任何输入或输出操作之前，应调用此函数。





>>C编译报错: implicit declaration of function xxx is invalid in C99 [-Wimplicit-function-declaration]

产生原因：
C语言是过程化的编程语言，程序执行顺序是从上到下。函数调用需要先声明后调用。 C99 默认不允许隐式声明(1999年推出的c语言标准)。
在之前的版本中，在C语言函数在调用前不声明，编译器会自动按照一种隐式声明的规则，为调用函数的C代码产生汇编代码。

解决办法：
在 main 函数调用前声明一下该函数。
（1）直接放到 main 函数前。
（2）或者定义在 .h 头文件中，在main函数前 引入该头文件。
（3）使用老版本编译。 【不推荐】





>>对字体（前景色）颜色进行调用的函数

void color(const unsigned short textColor)      //自定义函根据参数改变颜色 
{
    if(textColor>=0 && textColor<=15)     //参数在0-15的范围颜色
         SetConsoleTextAttribute(GetStdHandle(STD_OUTPUT_HANDLE), textColor);  //用一个参数，改变字体颜色
    else   //默认的字体颜色是白色
        SetConsoleTextAttribute(GetStdHandle(STD_OUTPUT_HANDLE), 7);
}

color(0); printf("黑色\n");
    color(1);  printf("蓝色\n");
    color(2);  printf("绿色\n"); 
    color(3);  printf("湖蓝色\n");
    color(4);   printf("红色\n");
    color(5);   printf("紫色\n");
    color(6);  printf("黄色\n"); 
    color(7);   printf("白色\n");
    color(8);   printf("灰色\n");
    color(9);  printf("淡蓝色\n");
    color(10);  printf("淡绿色\n");
    color(11);  printf("淡浅绿色\n"); 
    color(12);  printf("淡红色\n");
    color(13);  printf("淡紫色\n"); 
    color(14);  printf("淡黄色\n");
    color(15);  printf("亮白色\n");
    color(16);    //因为这里大于15，恢复默认的颜色 
    printf("回到原来颜色\n");   //直接使用颜色函数





>>关于局部变量在栈区上的使用

[ 错误代码 -- 会死循环 ]

#include <stdio.h>
int main()
{
    int i = 0;
    int arr[10] = {0};
    for(i=0; i<=12; i++)
   {
        arr[i] = 0;
        printf("hehe\n");
   }
    return 0;
}

分析：
1.  i和arr是局部变量                                                                    
     局部变量是放在栈区上的
     
     栈区内存的使用习惯是：
     先使用高地址空间，再使用低地址空间

2.  数组随着下标的增长地址
     是由低到高变化的
_______________________
|______________________|    高地址
|______________________|  <<<<   i     ( 根据代码显示是先创建的 i，所以在栈区中 i 在 arr 的上面 )
|______________________|
|______________________|
|______________________|  <<<<   arr [ 9 ]
|______________________|
|______________________|   ......
|______________________|
|______________________|  <<<<   arr [ 0 ]
|______________________|
|______________________|
|______________________|     低地址

（ 空两格是巧合，每个环境下可能都不一样 ）
[  没有报错是因为程序在死循环的走，不然就会报错为非法访问地址 ( 如果改成先创建arr再创建i的话就不会死循环，但是会报错非法访问地址 )  ]





>>位运算（按位与、按位或、异或）

按位与运算符（&）
参加运算的两个数，按二进制位进行“与”运算。

运算规则：只有两个数的二进制同时为1，结果才为1，否则为0。（负数按补码形式参加按位与运算）

即 0 & 0= 0 ，0 & 1= 0，1 & 0= 0， 1 & 1= 1。

例：3 &5  即 00000011 & 00000101 = 00000001 ，所以 3 & 5的值为1。

 

按位或运算符（|）
参加运算的两个数，按二进制位进行“或”运算。

运算规则：参加运算的两个数只要两个数中的一个为1，结果就为1。

即  0 | 0= 0 ,  1 | 0= 1  ， 0 | 1= 1  ,  1 | 1= 1 。

例：2 | 4 即 00000010 | 00000100 = 00000110 ，所以2 | 4的值为 6 。

 

异或运算符（^）
参加运算的两个数，按二进制位进行“异或”运算。

运算规则：参加运算的两个数，如果两个相应位为“异”（值不同），则该位结果为1，否则为0。

即 0 ^ 0=0  ， 0 ^ 1= 1  ， 1 ^ 0= 1  ， 1 ^ 1= 0 。

例： 2 ^ 4 即 00000010 ^ 00000100 =00000110 ，所以 2 ^ 4 的值为6 。





>>数据在内存中以2进制的形式存储
对于整数来说：

整数二进制有3种表示形式：原码、反码、补码
正整数：原码、反码、补码相同
负整数：原码、反码、补码要进行计算的


例：int a = -10 ( 32位 )

原码：按照数据的数值直接写出的二进制序列就是原码
           10000000000000000000000000001010 - 原码

反码：原码的符号位不变，其他位按位取反，得到的就是反码
           11111111111111111111111111110101- 反码

补码：反码 +1 ，得到的就是补码
           11111111111111111111111111110110- 补码

( 整数在内存中存储的是补码 ) 
在计算机系统中，数值一律用补码来表示和存储。原因在于，使用补码，可以将符号位和数值域统一处理；
同时，加法和减法也可以统一处理（CPU只有加法器）此外，补码与原码相互转换，其运算过程是相同的，不需要额外的硬件电路。





>>大小端：

int a = 0x11223344

	_______________________
	|                                    |
低	|   | 11 | 22 | 33 | 44 |   |	  高	
	|______________________|
             大端（存储）模式

	_______________________
	|                                    |
低	|   | 44 | 33 | 22 | 11 |   |	  高
	|______________________|
             小端（存储）模式


大端（存储）模式，是指数据的低位保存在内存的高地址中，而数据的高位，保存在内存的低地址中；
小端（存储）模式，是指数据的低位保存在内存的低地址中，而数据的高位,，保存在内存的高地址中。





>>char类型存放整数

char  内存            %d输出整数
_______________
|   00000000   | ->0                                        
|   00000001   | ->1	                                
|   00000010   | ->2                                        
|        ....           |                                               
|   01111111   | ->127 	                                
|--------------|                                             形成圆形成一个循环  
|   10000000   | ->-128                                  
|   10000001   | ->-127	                                
|   10000010   | ->-126                                  
|        ....           |                                                
|   11111110   | ->-2                                     
|   11111111   | ->-1 	                                
|______________|                                                

//巧记口诀:超出范围的数据如果是正数，则减去256;超出范围的数据如果是负数，则加上256.

如果是 unsigned char 的话就是从 0 - 255
因为char是一字节只有8个比特位所以最大就是11111111 '255'





>>数组名是数组首元素的地址

     但是有两个例外

1.sizeof(数组名) - 数组名表示整个数组，计算的是整个数组大小，单位是字节
2. &数组名 - 数组名表示整个数组，取出的是整个数组的地址

计算数组元素个数  len = sizeof（arr）/  sizeof（arr[0]）

——  > sizeof 是操作符，计算变量（类型）所占内存空间的大小，单位是字节，不关注内存中存放的内容

——  > strlen 是库函数，使用时需要引头文件，专门求字符串长度，只能针对字符串，向后一直找\0，统计\0之前出现的字符个数 

#include "stdio.h"
#include "string.h"

int main(){
    char a [1000] = {1,2,3,0,4,5};

    printf("%d",strlen(a));
    return 0;
}

strlen(a)会输出3 [ strlen函数遇到0会停止计算个数 ]


#include "stdio.h"
#include "string.h"
int main(){
    int a [1000] = {1,2,3,0,4,5};

    printf("%d",strlen(a));
    return 0;
}

警告：Incompatible pointer types passing 'int[1000]' to parameter of type 'const char *' 
[ 将“int[1000]”传递给“const char*”类型的参数的指针类型不兼容 ]

strlen(a)会输出1 [ strlen函数遇到0会停止计算个数 ]

发生这样的输出差距是因为数据在内存中存储的方式不同：     char  01 02 03 00 04 05
                                                                                                      int  01 00 00 00
                                                                                                             02 00 00 00 
                                                                                                             03 00 00 00  
                                                                                                             00 00 00 00   
                                                                                                             04 00 00 00  
                                                                                                             05 00 00 00





>>函数指针：指向函数的指针 or  存放函数地址的指针

                 数组名  !=  &数组名
[数字首元素地址]        [整个数字地址]

                 函数名  ==  &函数名 
[一样的]


函数指针变量和指针型函数的区别

　　　　Status (*compare)(Elemtype e,Elemtype temp);

　　这是一个函数指针变量，借此机会记录一下函数指针变量和指针型函数的区别。

一、写法上的区别

函数指针变量	指针型函数
int　(*function)(int i);	int  *function(int i){}
 

 

　　上面是一个例子，可看到函数指针变量只是在：*function处比指针型函数多了一对小括号，下面是两者的一般形式：

函数指针变量：

类型类型说明符 (*指针变量名)(形参表);

指针型函数：

类型说明符 *函数名(形参表){

}

二、概念上区别

函数指针变量：指向函数入口的指针变量(本质是变量)
　　　　在随笔的开头，LocateElem函数的形参中就有一个函数指针变量，在函数的调用过程中，只要将真正要使用的函数名作为实参传递，就可以调用改函数。为什么会这样           呢？因为函数在使用时，函数的名称就像数组名一样表示了一个地址，名称指向了函数的入口地址。通过将函数名赋值给一个函数指针变量，这个函数指针变量就指向了一个         特定函数；类似于定义一个变量，将数组的首地址赋值给该变量，就可以通过该指针处理这个数组。

指针型函数：返回值为指针类型的函数(本质是函数)
　　　　既然只指针型函数的本质是一个函数，则它一定具有相应的函数体。而这个函数与一般函数的区别就是他的返回值是一个指针类型，这里有点迷惑人的地方是：

      函数头上已经写了返回值的类型说明符是int(见一中的例子),为什么又说返回值是一个指针类型呢？这个理解是有些偏差的。

　　　　首先要清楚的是，定义一个指针变量，是得要确定指针指向的变量类型的。比如说：int *p;

　　上个语句执行后，会产生一个指针p,他指向一个整数类型。以此类推，在指针型函数中，类型说明符是对指针变量的一个说明，在int  *function(int i){}这个例子中，指针型       函数的意义是函数返回一个指向整数类型指针变量。

三、结语

　　在分辨这两个概念时，只要时刻谨记他们的本质就可以：函数指针变量本质是变量，那么对于变量的一切操作，它都兼容；指针型函数是一个函数，只是说函数的返回值比较特殊，是一个指向类型说明符的指针变量。


函数指针类型：

int (*) (int a, int b);  


//代码1
(*(void (*)())0)();

调用0地址处的函数
该函数无参，返回类型是void
1.void(*)( ) - 函数指针类型

2.(void(*)( ))0 - 对0进行强制类型转换，被解释为一个函数地址

3.*(void(*)( ))0 - 对0地址进行了解引用操作

4.(*(void(*)( ))0)( ) - 调用0地址处的函数


//代码2
void (*signal(int , void(*)(int)))(int);

1.signal和( )先结合，说明signal是函数名

2.signal函数的第一个参数的类型是int，第二个参数的类型是函数指针
   该函数指针，指向一个参数为int，返回类型是void的函数

3.signal函数的返回类型也是一个函数指针
   该函数指针，指向一个参数为int，返回类型是void的函数
   signal是一个函数的声明





>>转换说明符

%c             字符
%d             有符号十进制整数
%f             浮点数(包括float和doulbe)
%e(%E)     	   浮点数指数输出[e-(E-)记数法]
%g(%G)     	   浮点数不显无意义的零"0"
%i             有符号十进制整数(与%d相同)
%u             无符号十进制整数
%o             八进制整数        		     0123
%x(%X)     	   十六进制整数0f(0F)          0x1234
%p             指针
%s             字符串


〔标志〕〔输出最少宽度〕〔．精度〕〔长度〕类型

“％-md” ： 左对齐，若m比实际少时，按实际输出。
“%m.ns” ： 输出m位，取字符串(左起)n位，左补空格，当n>m or m省略时m=n
“%m.nf” ： 输出浮点数，m为宽度，n为小数点右边数位
“%3.1f” : 输入3852.99 输出3853.0


  左对齐："-"      "%-2s"代表左对齐2位
  右对齐："+"      "%+2s"代表右对齐2位

字符和字符串
%c格式对应的是单个字符。
%s格式对应的是字符串。

char和char*
%c对应类型为char
%s对应类型为char * , 即字符串。

用作输入时, 二者参数都要传char * 型. 
%c输入函数只会对一个字节空间赋值. 而%s会一直赋值,直到输入中遇到空白字符为止.
用作输出时, %c传char类型,输出一个字符. %s传char*类型参数, 输出到\0为止.

输入的时候scanf("%c", &a);这里的&不能少
而scanf("%s",s);这里不能有&符号



sizeof ( 数组名 )  - 数组名表示整个数组的  - 计算的是整个数组的大小
& 数组名  -  数组名表示整个数组，取出的是整个数组的地址
除此之外，所有的数组名都是数组首元素的地址  
